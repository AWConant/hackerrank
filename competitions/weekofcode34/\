#!/usr/bin/python3


import sys # stdout enumerate
from itertools import * # chain from_iterable product
from math import * # sqrt floor ceil
from copy import copy, deepcopy
from collections import * # Counter defaultdict deque
from queue import Queue
from heapq import heappush, heappop, heapify
from operator import * # itemgetter
from functools import reduce
from string import ascii_lowercase, ascii_uppercase

gi = lambda: int(input())
gis = lambda: list(map(int, input().split()))
gs = lambda: input()
skiplast = lambda x: range(len(x)-1)
is_even = lambda x: x%2 == 0

inf = float('inf')

def cached_solve(n, a, b):
    a.sort(reverse=True)
    b.sort(reverse=True)

    i = j = 0

    cache = dict()

    max_gcd = max_sum = -inf
    while i < n and j < n:
        in_order = (a[i], b[j]) if a[i] < b[j] else (b[j], a[i])
        if in_order not in cache:
            cache[in_order] = gcd(*in_order)

        cur_gcd = cache[in_order]
        cur_sum = a[i] + b[j]

        if cur_gcd == max_gcd:
            max_sum = max(max_sum, cur_sum)
        elif cur_gcd > max_gcd:
            max_gcd = cur_gcd
            max_sum = cur_sum

        if i == n-1:
            j += 1
        elif j == n-1:
            i += 1
        else:
            in_order1 = (a[i+1], b[j]) if a[i+1] < b[j] else (b[j], a[i+1])
            in_order2 = (a[i], b[j+1]) if a[i] < b[j+1] else (b[j+1], a[i])
            if in_order1 not in cache:
                cache[in_order1] = gcd(*in_order1)
            if in_order2 not in cache:
                cache[in_order2] = gcd(*in_order2)

            if cache[in_order1] > cache[in_order2]:
                i += 1
            else:
                j += 1

    return max_sum, max_gcd

def solve(n, a, b):
    a.sort(reverse=True)
    b.sort(reverse=True)

    i = j = 0
    max_gcd = max_sum = -inf
    while True:
        #print('Fast considering', a[i], 'and', b[j])
        cur_gcd = gcd(a[i], b[j])
        cur_sum = a[i] + b[j]

        if cur_gcd == max_gcd:
            max_sum = max(max_sum, cur_sum)
        elif cur_gcd > max_gcd:
            max_gcd = cur_gcd
            max_sum = cur_sum

        if i == n-1 and j == n-1:
            break

        if i == n-1:
            j += 1
        elif j == n-1:
            i += 1
        elif gcd(a[i+1], b[j]) > gcd(a[i], b[j+1]):
        #elif a[i+1] > b[j+1]:
            i += 1
        else:
            j += 1

    return max_sum, max_gcd

def naive(n, a, b):
    max_gcd = max_sum = -inf
    for a_i, b_j in product(a, b):
        cur_gcd = gcd(a_i, b_j)
        cur_sum = a_i + b_j

        if cur_gcd == max_gcd:
            max_sum = max(max_sum, cur_sum)
        elif cur_gcd > max_gcd:
            max_gcd = cur_gcd
            max_sum = cur_sum

    return max_sum, max_gcd

def one_array(n, a, b):
    MAXVAL = 10**6

    a_counts = Counter(a)
    b_counts = Counter(b)

    count = [0]*(MAXVAL+1)
    for i in range(1, MAXVAL+1):
        for j in range(i, MAXVAL+1, i):
            count[i] += a_counts[j]

    best = 0
    for i in range(1, MAXVAL+1):
        if count[i] > 1:
            best = max(best, i)

    return best

def fancy(n, a, b):
    a_counts = Counter(a)
    b_counts = Counter(b)

    MAXVAL = max(chain(a, b))

    def iterate(i):
        a_item_count = b_item_count = 0
        a_val = b_val = 1

        for j in range(i, MAXVAL, i):
            a_item_count += a_counts[j]
            if a_counts[j] and j > a_val:
                a_val = j

            b_item_count += b_counts[j]
            if b_counts[j] and j > b_val:
                b_val = j

            if a_item_count >= 1 and b_item_count >= 1:
                return a_val + b_val

        return None


    for i in range(MAXVAL, 1, -1):
        ret = iterate(i)
        if ret is not None:
            return retu

def main():
    n = gi()
    a = gis()
    b = gis()

    print(fancy(n, a, b))

def stresstest():
    from random import randrange
    while True:
        n = 3
        a = [randrange(1, 20 + 1) for _ in range(n)]
        b = [randrange(1, 20 + 1) for _ in range(n)]

        fast_sol = solve(n, a, b)
        opt_sol = naive(n, a, b)

        if fast_sol != opt_sol:
            print(a, b)
            print('Fast:', fast_sol)
            print('Opt:', opt_sol)
            return
        else:
            print(a, b)

main()
#stresstest()
